---
title: "Análisis datos elecciones"
format:
  revealjs:
    theme: [style.scss]
    embed-resources: true
execute: 
  echo: true
---

## Análisis datos elecciones

```{r}
rm(list = ls())
library(tidyverse)

```

```{r}
# NO TOQUES NADA
election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv") #archivo con las elecciones al congreso
cod_mun <- read_csv(file = "./data/cod_mun.csv") #archivo con los códigos y nombres de cada municipio
surveys <- read_csv(file = "./data/historical_surveys.csv") #siglas de cada partido
abbrev <- read_csv(file = "./data/siglas.csv") #encuestas electorales desde 1982.
```

------------------------------------------------------------------------

## 1. Depuración del conjunto *election_data*

Primeramente vamos a depurar y trabajar con el conjunto *election_data*. Esto conlleva la organización de los datos, comprobación que el tipo de dato de cada variable sea el adecuado, manejo de los ausentes, etc.

```{r}
election_data_tidy <-
  election_data |> 
  pivot_longer(cols = -c(tipo_eleccion:votos_nulos),
               names_to = "partidos", values_to = "votos",
               values_drop_na = TRUE) |> 
  # tenemos algunas lógicas que deberían ser números
  mutate(across(where(is.logical), as.numeric))

election_data_tidy
```

------------------------------------------------------------------------

Como sabemos, en estadística información = varianza por tanto hay variables que debemos eliminar y para ello primero observamos la cantidad de valores distintos que hay en cada variable para después eliminar aquellas que presenten valores constantes, es decir, que el número de valores distintos sea igual a uno.

En este caso, estas variables son tipo_elección, vuelta y codigo_distrito_electoral.

Además, vamos a añadir una variable fecha considerando que todas las elecciones han sido realizadas el 1 de enero

```{r}
#1º Sacamos los valores distintos de cada variable
n_dist <-
  election_data_tidy |> 
  summarise(across(everything(), n_distinct)) #recorremos todas las variables y sacamos los valores distintos
n_dist

#2º Seleccionamos todas las variables menos las que no nos aportaban información
election_data_tidy <-
  election_data_tidy |> 
  select(-c(tipo_eleccion, vuelta, codigo_distrito_electoral))
election_data_tidy

#3º Añadimos la variable fecha
library(glue)
election_data_tidy <-
  election_data_tidy |> 
  mutate("fecha" = as_date(glue("{anno}-{mes}-01")), .before = everything()) |> 
  select(-anno, -mes)
election_data_tidy
```

------------------------------------------------------------------------

Ahora vamos a crear la variable id para poder realizar de manera más rápida y eficiente el borrado de duplicados por municipio, fecha electoral y partido

```{r}
election_data_tidy <-
  election_data_tidy |> 
  mutate("id_mun" = glue("{codigo_ccaa}_{codigo_provincia}_{codigo_municipio}"),
         "id_elec" = glue("{fecha}_{id_mun}"), .after = fecha) |> 
  mutate("id_result" = glue("{id_elec}_{partidos}"), .before = everything()) |> 
  distinct(id_result, .keep_all = TRUE)
election_data_tidy
```

------------------------------------------------------------------------

Además, necesitamos seleccionar sólo aquellos partidos que nos nos interesan. Pero para ello debemos tener en cuenta que hay partido que tienen o tenían federaciones, sucursales con otros nombres por lo que es necesario recategorizarlos.

Nos encontramos con una base de datos llamada "abbrev" cuya única utilidad/información que aporta es la asignación de las siglas correspondientes a cada uno de los partidos políticos. Por ello, mediante el uso de un join (left_join), uniremos dicha información a nuestra base de datos principal en tidy data. De este modo, obtendremos una nueva columna a la que llamaremos "siglas" y que nos será de utilidad más adelante para llamar y referirnos a cada uno de los partidos.

El primer paso es darnos cuenta de que las dos columnas por las que uniríamos nuestras tablas en el join (las columnas que tienen los nombres de los partidos), no tienen el mismo nombre. Por ello, renombramos una de ellas para poder unirlas y, además, no estaría mal pasar ambas columnas de partidos a mayúsculas para así poder evitar cualquier tipo de error posterior a la hora de unir los nombres.

```{r}
abbrev

election_data_tidy <- 
  election_data_tidy |> 
  left_join(abbrev, by = c("partidos"="denominacion")) |> 
  mutate(siglas=str_to_upper(siglas))
  
election_data_tidy <-
  election_data_tidy |> 
  mutate("votos" = sum(votos, na.rm = TRUE), .by = c(id_elec, siglas)) |> 
  distinct(id_elec, siglas, .keep_all = TRUE)
election_data_tidy
```

Una vez tenemos la columna siglas incorporada a nuestra base de datos principal, observamos que no todas las siglas tienen el mismo formato. Por ejemplo, tenemos en siglas PP y P.P. Para ello, vamos a llevar a cabo el código correspondiente para limpiar la variable y estandarizar el formato elimimando los puntos. Los guiones no los vamos a modificar ya que no afectarán más tarde de cara a la funcion de contains para recategorizar.

```{r}
election_data_tidy <-
  election_data_tidy |> 
  mutate(siglas = str_replace_all(siglas, "\\.", ""))
election_data_tidy
```

```{r}
election_data_tidy <-
  election_data_tidy |> 
  mutate(siglas = str_replace_all(siglas, "\\,|\\'", ""))
election_data_tidy
```

Hacemos un distinct de la variable siglas para terminar de comprobar que no hay nada raro en las siglas de los partidos que nos interesan. Queremos quw haya concordancia y que todas las siglas de los partidos iguales sean iguales.

```{r}
election_data_tidy |>  
  distinct(siglas)
```

```{r}
election_data_tidy <- 
  election_data_tidy |> 
  mutate(siglas = ifelse(str_detect(siglas, "PAÍS"), "MP", siglas))
```

```{r}
election_data_tidy <- 
election_data_tidy |>
  mutate("siglas" =
           case_when(str_detect(siglas, "PSOE") ~ "PSOE",
                     str_detect(siglas, "PP") ~ "PP",
                     str_detect(siglas, "CS") ~ "CS",
                     str_detect(siglas, "PNV") ~ "PNV",
                     str_detect(siglas, "BLOQUE NACIONALISTA GALEGO") ~ "BNG",
                     str_detect(siglas, "PODEMOS") ~ "PODEMOS",
                     str_detect(siglas, "ERC|ESQUERRA") ~ "ERC",
                     str_detect(siglas, "BILDU") ~ "BILDU",
                     str_detect(siglas, "MP") ~ "MP",
                     str_detect(siglas, "VOX") ~ "VOX",
                     str_detect(siglas, "CIU") ~ "CIU",
                     TRUE ~ "OTROS"))

```

## 2. Depuración del conjunto *surveys*

Debes descartar las encuestas que:

\- se refieran a elecciones anteriores a 2008

\- sean a pie de urna

\- tamaño muestral desconocido o inferior a 500.

\- tenga 1 día o menos de trabajo de campo.

Ahora vamos a llevar a cabo la limpieza de la base de datos de surveys. Lo primero que se pide es filtrar por años y descartar aquellas observaciones anteriores al 2008. Para comprobar que años tenemos en la base de datos llevaremos un distinct del año

```{r}
surveys |> 
  distinct(year(date_elec))
```

Observamos que el año más reciente con el que contamos es 2019. Y, como hemos especificado antes en la depuracion de election_data_tidy, solo queremos trabajar con los datos de 2008 a 2019. Por ello, bastará con seleccionar los datos mayores a 2008.

```{r}
surveys <- 
  surveys |> 
  filter(year(date_elec) >= 2008) |> 
  filter(exit_poll == FALSE) |>
  filter(size > 500)
```

```{r}
surveys |> 
  distinct(exit_poll)
```

```{r}
surveys <- surveys |> 
  filter(year(date_elec) >= 2008 & 
           exit_poll == FALSE &
           size > 500 &
           as.numeric(difftime(field_date_to, field_date_from, units = "days")) > 1) |> 
  drop_na(size)
surveys
```

```{r}
surveys_tidy <- 
  surveys |> 
  pivot_longer(cols = -c(1:10),
               names_to = "partidos",
               values_to = "votos",
               values_drop_na = TRUE)
surveys_tidy
```
