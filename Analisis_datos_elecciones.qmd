---
title: "Analisis_datos_elecciones"
format:
  revealjs:
    theme: [style.scss]
    embed-resources: true
execute: 
  echo: true
---

------------------------------------------------------------------------

## Análisis datos elecciones

```{r}
#| eval: true
rm(list = ls())
library(tidyverse)
library(glue)
```

```{r}
# NO TOQUES NADA
election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv") #archivo con las elecciones al congreso
cod_mun <- read_csv(file = "./data/cod_mun.csv") #archivo con los códigos y nombres de cada municipio
surveys <- read_csv(file = "./data/historical_surveys.csv") #encuestas electorales desde 1982.
abbrev <- read_csv(file = "./data/siglas.csv") #siglas de cada partido
```

## 1. Depuración del conjunto *election_data*

Primeramente vamos a depurar y trabajar con el conjunto *election_data*. Esto conlleva la organización de los datos, comprobación que el tipo de dato de cada variable sea el adecuado, manejo de los ausentes, etc.

```{r}
election_data_tidy <-
  election_data |> 
  pivot_longer(cols = -c(tipo_eleccion:votos_candidaturas),
               names_to = "partidos", values_to = "votos",
               values_drop_na = TRUE) |> 
  # tenemos algunas lógicas que deberían ser números
  mutate(across(where(is.logical), as.numeric))

election_data_tidy
```

------------------------------------------------------------------------

Como sabemos, en estadística información = varianza por tanto hay variables que debemos eliminar y para ello primero observamos la cantidad de valores distintos que hay en cada variable para después eliminar aquellas que presenten valores constantes, es decir, que el número de valores distintos sea igual a uno.

En este caso, estas variables son tipo_elección, vuelta y codigo_distrito_electoral.

Además, vamos a añadir una variable fecha considerando que todas las elecciones han sido realizadas el 1 de enero

```{r}
#1º Sacamos los valores distintos de cada variable
n_dist <-
  election_data_tidy |> 
  summarise(across(everything(), n_distinct)) #recorremos todas las variables y sacamos los valores distintos
n_dist

#2º Seleccionamos todas las variables menos las que no nos aportaban información
election_data_tidy <-
  election_data_tidy |> 
  select(-c(tipo_eleccion, vuelta, codigo_distrito_electoral))

#3º Añadimos la variable fecha
library(glue)
election_data_tidy <-
  election_data_tidy |> 
  mutate("fecha" = as_date(glue("{anno}-{mes}-01")), .before = everything()) |> 
  select(-anno, -mes)
election_data_tidy
```

Además, necesitamos seleccionar sólo aquellos partidos que nos nos interesan. Pero para ello debemos tener en cuenta que hay partido que tienen o tenían federaciones, sucursales con otros nombres por lo que es necesario recategorizarlos

```{r}
election_data_tidy <- 
  election_data_tidy |> 
  left_join(abbrev, by = c("partidos"="denominacion")) |> 
  mutate(siglas = str_to_upper(siglas))
```

```{r}
election_data_tidy <- 
  election_data_tidy |> 
  mutate(siglas = str_replace_all(siglas, "\\.", ""))
```

```{r}
election_data_tidy <- 
  election_data_tidy |> 
  mutate(siglas = str_replace_all(siglas, "\\,|\\'", ""))
```

```{r}
election_data_tidy |> 
  distinct(siglas)
```

```{r}
election_data_tidy <- 
  election_data_tidy |> 
  mutate(siglas = ifelse(str_detect(partidos, "PAÍS"), "MÁS PAÍS", siglas))
```

```{r}
election_data_tidy <- 
  election_data_tidy |>
  mutate("siglas" =
           case_when(str_detect(siglas, "PSOE") ~ "PSOE",
                     str_detect(siglas, "PP") ~ "PP",
                     str_detect(siglas, "CS|C´S") ~ "CS",
                     str_detect(siglas, "PNV") ~ "PNV",
                     str_detect(siglas, "BNG") ~ "BNG",
                     str_detect(partidos, "CONVERGENCIA I UNIO") ~ "CIU",
                     str_detect(siglas, "PODEMOS|EB-B|IU") ~ "PODEMOS",
                     str_detect(siglas, "ERC|ESQUERRA") ~ "ERC",
                     str_detect(siglas, "BILDU|EA|ARALAR") ~ "BILDU",
                     str_detect(siglas, "MÁS PAÍS") ~ "MP",
                     str_detect(siglas, "VOX") ~ "VOX",
                     TRUE ~ "OTROS"))
```

Ahora vamos a crear la variable id para poder realizar de manera más rápida y eficiente el borrado de duplicados por municipio, fecha electoral y las siglas del partido.

```{r}
election_data_tidy <-
  election_data_tidy |> 
  mutate("id_mun" = glue("{codigo_ccaa}_{codigo_provincia}_{codigo_municipio}"),
         "id_elec" = glue("{fecha}_{id_mun}"), .after = fecha) |> 
  mutate("id_total" = glue("{id_elec}_{siglas}"), .before = everything()) |> 
  distinct(id_total, .keep_all = TRUE)


election_data_tidy <-
  election_data_tidy |> 
  mutate("votos" = sum(votos, na.rm = TRUE), .by = c(id_total)) |> 
  distinct(id_total, .keep_all = TRUE)

election_data_tidy
```

## 2. Depuración del conjunto *surveys*

Debes descartar las encuestas que: - se refieran a elecciones anteriores a 2008 - sean a pie de urna - tamaño muestral desconocido o inferior a 500. - tenga 1 día o menos de trabajo de campo.

```{r}
surveys <- surveys |> 
  filter(year(date_elec) >= 2008 & 
           exit_poll == FALSE &
           size > 500 &
           as.numeric(difftime(field_date_to, field_date_from, units = "days")) > 1) |> 
  drop_na(size)
surveys
```

```{r}
surveys_tidy <- 
surveys |> 
  pivot_longer(cols = -c(1:10),
               names_to = "partidos",
               values_to = "votos",
               values_drop_na = TRUE)
surveys_tidy
```

```{r}
surveys_tidy <- 
  surveys_tidy |>
  mutate(partidos =
           case_when(str_detect(partidos, "PSOE") ~ "PSOE",
                     str_detect(partidos, "PP") ~ "PP",
                     str_detect(partidos, "CS|C´S") ~ "CS",
                     str_detect(partidos, "PNV") ~ "PNV",
                     str_detect(partidos, "BNG") ~ "BNG",
                     str_detect(partidos, "PODEMOS|EB-B|IU") ~ "PODEMOS",
                     str_detect(partidos, "ERC|ESQUERRA") ~ "ERC",
                     str_detect(partidos, "BILDU|EA|ARALAR") ~ "BILDU",
                     str_detect(partidos, "MÁS PAÍS") ~ "MP",
                     str_detect(partidos, "VOX") ~ "VOX",
                     str_detect(partidos, "CIU") ~ "CIU",
                     TRUE ~ "OTROS"))
surveys_tidy
```

## PREGUNTAS OBLIGATORIAS

1.  ¿Qué partido fue el ganador en los municipios con más de 100.000 habitantes (censo) en cada una de las elecciones?

```{r}
ganadores <- 
  election_data_tidy |> 
  filter(censo > 100000) |>  
  group_by(id_elec, id_mun) |>  
  arrange(desc(votos)) |> 
  slice_max(votos, n = 1, with_ties = FALSE) |>  
  select(id_elec, id_mun, ganador = siglas, votos_ganador = votos) |> 
  ungroup()

ganadores
```

3.  

4.  ¿Cómo analizar la relación entre censo y voto? ¿Es cierto que determinados partidos ganan en las zonas rurales?

```{r}
extrafont::fonts()

ejercicio_4 <- 
  election_data_tidy |>
  group_by(id_elec) |> 
  summarise(votos_Totales = (votos_blancos + votos + votos_nulos),
            censo = sum(censo), 
            porcentaje = (votos_Totales/censo)*100) |> 
  ungroup()
#"id_mun" = glue("{codigo_ccaa}_{codigo_provincia}_{codigo_municipio}"

library(ggplot2)
library(plotly)

ejercicio_4 <- 
  ejercicio_4 |> 
  mutate(censo = as.numeric(censo))

# Crear la gráfica de dispersión con la recta de regresión
grafica_regresion <- 
  ggplot(ejercicio_4, 
         aes(x = censo, 
             y = votos_Totales)) +
  geom_point(color = "#884e96", 
             size = 1, 
             alpha = 0.6) +  # Puntos de dispersión
  scale_x_continuous(breaks = seq(0, 15000000, by = 1000000), labels = scales::comma) +
  scale_y_continuous(labels = scales::comma) +
  stat_smooth(method = "lm", 
              color = "#403344", 
              se = TRUE) +  # Línea de regresión con banda de error
  labs(
    title = "Relación entre Censo y Votos Totales",
    x = "Censo",
    y = "Votos Totales"
  ) +
  theme_minimal() +
  theme( plot.title = element_text(family ="Comic Sans MS"),
    panel.background = element_rect(fill = "white"),
    legend.position = "bottom",
    axis.text.x = element_text(angle = 30, size = 8),
    axis.title.y = element_text(family = "Rockwell"),
    axis.title.x = element_text(family = "Rockwell"))
grafica_regresion
  
```

## Gracias a la recta de regresión podemos observar que existe una relación directamente proporcional entre el censo y los votos totales, ya que, cuanto más censo haya, más votos hay y viceversa.

¿Es cierto que determinados partidos ganan en las zonas rurales?

```{r}
library(ggplot2)

# Filtrar los datos para las zonas rurales
rural_data <- 
  election_data_tidy |>
  mutate(zona = if_else(censo < 30000, "Rural", "Urbana")) |>
  filter(zona == "Rural") |>
  group_by(siglas) |>
  summarise(votos_Totales = sum(votos)) |>
  arrange(desc(votos_Totales)) |> 
  ungroup()

# Crear el gráfico de barras
grafica_4_2 <-
  ggplot(rural_data, 
       aes(x = fct_reorder(siglas, -votos_Totales), 
           y = votos_Totales, 
           fill = siglas)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("PP" = "#4D7EAB", 
                               "PSOE" = "#BC1119", 
                               "VOX" = "#53C100" , 
                               "PODEMOS" = "#AE8FD2", 
                               "CS" = "#F38A5D", 
                               "ERC" = "#FFB900", 
                               "MP" = "#00BECC", 
                               "PNV" = "#0E7535", 
                               "BILDU" = "#87B560", 
                               "BNG" = "#64AAD2",
                               "OTROS"="grey"))+
  labs(title = "Votos por partido en zonas rurales",
       x = "Partido",
       y = "Votos totales",
       fill = "Partido") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
grafica_4_2
```

```{r}
election_data_tidy<-
election_data_tidy |> 
  mutate(participacion_total = participacion_1 + participacion_2) 

#Utilizando terciles
election_data_tidy <- 
  election_data_tidy |> 
  mutate(
    nivel_participacion = case_when(
      participacion_total >= 0 & participacion_total <= 851101 ~ "baja",
      participacion_total > 851101 & participacion_total <= 1702203 ~ "media",
      TRUE ~ "alta"))

participacion_baja <- 
  election_data_tidy |> 
  filter(nivel_participacion == "baja")

#tabla final con baja participación y solo los 11 partidos que nos interesan.
participacion_baja <- 
  participacion_baja |> 
  filter(siglas != "OTROS")

library(ggplot2)

participacion_baja <- 
  participacion_baja |> 
  mutate("voto_por_partido" = sum(votos_candidaturas), .by = siglas) |> 
  select(participacion_total, nivel_participacion, voto_por_partido, siglas)
  
participacion_baja

grafica_votos <- 
  ggplot(participacion_baja) +
  geom_col(aes(x = fct_reorder(siglas, -voto_por_partido),
               y = voto_por_partido,
               fill = fct_reorder(siglas, -voto_por_partido))) +  
  scale_y_continuous()
  labs(
    title = "Comparación de votos por partido",
    x = "Partidos",
    y = "Votos",
    fill = "Partidos"
  ) +
  scale_fill_manual(values = c("PP" = "#4D7EAB", 
                               "PSOE" = "#BC1119", 
                               "VOX" = "#53C100" , 
                               "PODEMOS" = "#AE8FD2", 
                               "CS" = "#F38A5D", 
                               "ERC" = "#FFB900", 
                               "MP" = "#00BECC", 
                               "PNV" = "#0E7535", 
                               "BILDU" = "#87B560", 
                               "BNG" = "#64AAD2")) +
  theme_minimal() +  
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)  
  )

grafica_votos
```

### 12.5 ¿Cómo calibrar el error de las encuestas (recordemos que las encuestas son de intención de voto a nivel nacional)?

Queremos comparar los datos reales obtenidos en las elecciones (election_data) con los datos estimados que se iban a obtener (surveys). Observamos que los datos de las encuestas por partido estan a nivel nacional, mientras que los datos obtenidos estan a nivel municipal, por lo que tendremos que calcular los votos a nivel nacional para poder compararlos.

Calculamos los votos por fecha electoral y por partido

```{r}
votosXFechaPartido <- election_data_tidy |>
  filter(siglas != "OTROS") |>
  summarise(votos_tot_x_partido = sum(votos),
        	.by = c(fecha, siglas)) |>
  mutate(fecha = format(fecha, "%Y-%m"))
votosXFechaPartido
```

Calculamos los votos por fecha electoral

```{r}
votosXfecha <- election_data_tidy |>
  filter(siglas != "OTROS") |>
  summarise(votos_tot = sum(votos), .by = fecha) |>
  mutate(fecha = format(fecha, "%Y-%m"))
votosXfecha
```

Ahora calculamos el porcentaje que tiene cada partido respecto al total de votos

```{r}
TablaFinal <- votosXfecha |>
  inner_join(votosXFechaPartido) |>
  mutate(porcentaje_votos = 100 *(votos_tot_x_partido / votos_tot))
TablaFinal
```

Observamos que las emperesas realizan varias encuestas en diferentes dias para una misma fecha electoral asique hacerlo mas sencillo vamos a calcular la media del valor obtenido en las encuestas para cada partido que realiza una misma empresa para una fecha electoral.

```{r}
surveys_union <- 
  surveys_tidy |>
  summarise(estimacion = mean(votos), .by =c(partidos, date_elec, pollster)) |>
  mutate(date_elec = format(date_elec, "%Y-%m"))
surveys_union
```

Ahora que tenemos el porcentaje de votos a nivel nacional tenemos que unir la tabla que contiene el porcentaje de votos a nivel nacional con la tabla de las encuestas

```{r}
TablaUnion <- surveys_union |>
  inner_join(TablaFinal, by = c("date_elec" = "fecha", "partidos" = "siglas"))
TablaUnion
```

Calculamos el error absoluto porcentual entre las encuestas y los datos reales

```{r}
Error <- 
  TablaUnion |>
  summarise(errorPorcentual = abs(estimacion - porcentaje_votos), .by = c(date_elec, pollster, partidos)) |>
  mutate(errorPorcentual = round(errorPorcentual, 5)) |>
  drop_na(errorPorcentual)
Error
```

El error porcentual nos indica la magnitud de la discrepancia entre lo que la encuesta predijo y lo que realmente ocurrió, por partido y por fecha electoral.

Para calibrar el error de las encuestas vamos a ajustar los resultados de las encuestas en funcion del error que hemos calculado, con el objetivo de que las predicciones sean más precisas o más cercanas a la realidad. Para ello vamos a unir la tabla **Error** y la tabla **surveys_union** para sumarle a la variable estimacion el error porcentual, haciendo asi que ese nuevo porcentaje se acerque mas al verdadero valor de las elecciones.

```{r}
surveys_union |>
  inner_join(Error) |>
  mutate(PorcentajeCalibrado = estimacion + errorPorcentual)
```

Observamos que ahora la varible **PorcentajeCalibrado** tiene unos valores mas cercanos al verdadero valor de la encuesta de la variable **porcentaje_votos** de la tabla TablaUnion. De forma que para calibrar los resultados de las encuestas hemos sumado la diferencia que habia entre las encuestas y los resultados reales y hemos obtenido los resultados reales de la encuesta.

## 12.6. ¿Qué casas encuestadoras acertaron más y cuáles se desviaron más de los resultados?

Para saber que casa encuestadoras acertaron mas y cuales acertaron menos tenemos que ver cuales tienen un valor mas alto como media (se han alejado mas del verdadero resultado) y cuales tienen un valor mas bajo (se acercan mas al verdadero resultado)

Vamos a ver por empresa la media del error para obtener una idea general de qué tan precisas o imprecisas fueron sus predicciones en promedio. No tenemos en cuenta la fecha de las elecciones porque nos interesa saberu en general que casa encuestadora acierta mas o acierta menos sin centrarnos en unas elecciones especificas

```{r}
Media <- Error |>
  summarise(mediaError = mean(errorPorcentual, na.rm = TRUE),
        	.by = c(pollster))
Media
```

Vamos a ver que 3 casas encuestadoras se alejaron mas del verdadero resultaado de las elecciones.

```{r}
mayorError <- 
  Media |>
  slice_max(mediaError, n = 3)
mayorError
```

Observamos que ASEP es la casa encuestadora que mas falla respecto a los resultados reales de las elecciones, seguido de NETQUEST y de MYWORD. Ahora vemos que casas encuestadoras se acercaron mas al verdadero resultado de las elecciones.

```{r}
menorError <- 
  Media |>
  slice_min(mediaError, n = 3)
```

La casa encuestadora que mas ha acertado los resultados reales en caracter general ha sido ELECTOPANEL, seguida de SOCIOMETRICA y VOX PUBLICA.
